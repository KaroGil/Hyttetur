# Prosjektrapport
https://git.app.uib.no/inf112/23v/inf112.23v/-/wikis/semesteroppgave

Hvordan fungerer rollene i teamet? Trenger dere å oppdatere hvem som er teamlead eller kundekontakt?

Vi har justert rollene noe for å beskrive litt mer hva hver persons hovedfokus skal være/har vært. 
Rollene slik de ser ut idag er:
Karolina: Teamlead, testansvarlig
Mathias: Kundekontakt, menydesign
Thomas: Grafisk, funksjonalitet
Finn: Mapdesign, modularitet
Selv om noen fikk som rolle å være ansvarlig over det grafiske eller over tester
betyr det ikke at det var dem som laget alt det grafiske eller alle testene,
men at de så til at det ble gjort og eventuelt delegerte det videre.

 
De ulike rollene innebærer:
 - Teamlead: se til at møter blir holdt og skrivermøtereferat fra møtene.
 - Kundekontakt: ser til at produktet møter kravene.
 - Grafisk: ser til den grafiske delen av spillet. Lager grafiske detaljer selv eller deligerer arbeidet videre til et annet medlem av gruppen. Passer på at kildene blir brukt på en riktig måte og blir ført opp.
 - Test-ansvarlig: ansvarlig for å se til at vi har tester som tester koden på en hensiktsmessig måte. Forsikre seg om at testene har nok covarage og justere dersom det ikke er.
 - Funksjonalitet: Ansvarlig for hvordan fysikken i spillet fungerer
 - Meny/map -design. Litt mer spesifikke oppgaver som forklarer seg selv. 
 - Se til at metoder har en spesifikke oppgave og ikke blir for lange

Alle har i tillegg rollen som utvikler på dette prosjektet og dette innebærer at vi alle skriver kode og videreutvikler programmet.

Er det noen erfaringer enten team-messig eller mtp prosjektmetodikk som er verdt å nevne? Synes teamet at de valgene dere har tatt er gode? Hvis ikke, hva kan dere gjøre annerledes for å forbedre måten teamet fungerer på?

Som sagt i tidligere raporter har vi valgt å bruke kanban brett for organisasjonen av oppgaver. Dette har fungert bra og har gitt oss en god oversikt over hvilke oppgaver som vi har gjennstående samt å holde kontroll på hvem som jobber med hva. Det har til tider vært små problemer med at det ikke alltid har vært like stor oppfølging i dette brettet og at medlemer har glemt å oppdatere brettet etter oppgavene har blitt løst. Dette ble kjapt oppklart enten av meldinger i kommunikasjonskanalen vår eller på neste gruppemøte og skapte ikke for store problemer for gruppearbeidet.


Hvordan er gruppedynamikken? Er det uenigheter som bør løses?

Gruppedynamikken har fungert bra i den siste strekningen av oppgaven. Vi har hatt god kommunikasjone og alle vet hvordan programmet er strukturert og hvordan koden fungerer. Alle uenigheter som vi har hatt har vi løst med å snakke sammen og komme til en felles konklusjon dersom vi hadde ulike meninger. Dette har fungert bra og vi har med dette fått mindre misfårståelser i koden vår og spillet har fungert bedre på grunn av dette.
Hvordan fungerer kommunikasjonen for dere?
Etter at vi flyttet kommunikasjonskanalen fra discord til discord og messenger har kommunikasjonen blitt mye bedre. Det er mye enklere å få kontakte de ulike gruppemedlemene siden vi sjekker messenger oftere enn vi sjekker discord.
Kommunikasjonen i gruppen kunne være bedre og det har vært noen få misfårståelser men vi har jobbet med dette og har opklart dem.

Under vurdering vil det vektlegges at alle bidrar til kodebasen. Hvis det er stor forskjell i hvem som committer, må dere legge ved en kort forklaring for hvorfor det er sånn. Husk å committe alt. (Også designfiler)

Alle i gruppen har jobbet omtrent like mye. Vi har hjulpet hverandre med å kode og dersom noen har stått fast spurte vi hverandre. Dersom det finnes mye forskjell på antall commits i repositoret kan det være på grunn av parprogrammeringen eller at noen av oss commiter skjeldnere enn andre, men skriver like mye kode.
Referat fra møter siden forrige leveranse skal legges ved (mange av punktene over er typisk ting som havner i referat).
https://git.app.uib.no/karmoywarios/hyttetur/-/wikis/M%C3%B8tereferat-m%C3%B8te-20.04
https://git.app.uib.no/karmoywarios/hyttetur/-/wikis/M%C3%B8tereferat-m%C3%B8te-25.04
https://git.app.uib.no/karmoywarios/hyttetur/-/wikis/M%C3%B8tereferat-m%C3%B8te-02.05
https://git.app.uib.no/karmoywarios/hyttetur/-/wikis/M%C3%B8tereferat-m%C3%B8te-05.05


For siste innlevering (Oblig 4): Gjør et retrospektiv hvor dere vurderer hvordan hele prosjektet har gått. Hva har dere gjort bra, hva hadde dere gjort annerledes hvis dere begynte på nytt?
Vi har kommet langt siden vi først startet prosjektet og startet å jobbe sammen. 

Kommunikasjonen har blitt mye bedre siden vi startet å kommunisere gjennom messenger og snakke tydeligere om hvilke oppdateringer vi har gjort i programmet. Gjennom å begynne med standup, altså at alle forteller kort om hva de har gjort, på begynnelsen av møtene har møtene gått mer effektivt og vi har hatt mindre uenigheter både i koden og mellom hverandre. Med å ha dette på begynnelsen av møtene vet vi også bedre hva de forskjellige personene har jobbet med og har bedre kontroll over koden.
Rapporten nevner hvordan vi har brukt kanban brett til å holde kontroll over oppgavene som utføres. Dette har også gått mye bedre utover prosjektet på begynnelsen var det litt problemer siden vi var nye til dette og måtte bli vandt til det men vi ble bedre og bedre med å huske å oppdatere brettet. Det hender enda tilfeller der vi glemmer det litt ut, men dette er uansett mye bedre enn begynnelsen.
Gjennom prosjekt-prosessen har vi tatt i bruk par-programmering metoden. Dennne fungerte meget bra i begynnelses-fasen dersom gruppemedlemene kunne bli bedre kjent med hverandre og hverandres kodestil. Parprogrammering fungerte bra på begynnelsen også fordi vi fikk lære hvordan libgdx biblioteket fungerer sammen slik at alle skjønner hvordan dette brukes. Det var også greit å ha noen andre å diskutere problemene over i starten. Videre i prosessen gikk vi litt vekk fra det men fortsatte litt der  vi så det var gunstig. Dette var en teknikk vi likte veldig bra og som fungerte bra for oss.
En ting vi kunne ha begynt på tidligere er å vektlegge testing enda mer. Til tider glemte vi ut å skrive tester til den koden vi implementerte, om vi hadde gjort dette mer kunne vi ha håndtert bugs som kom opp lettere. Vi ble bedre på dette til slutt og så hvordan dette hjalp med kodeskriving.
Om vi skulle ha startet på nytt hadde vi prøvd å lære av de feilene vi gjorde denne gange og utvikle oss ut derfra. Vi hadde fokusert mer på testing og begynt å kommunisere gjennom messenger fra begynnelsen av. Til neste gang hadde det også være lurt å ha en gjennomgang i gruppen av hvordan git fungerer tidligere og finne ut av dette kjappere. Dette hadde gjort det lettere å fort begynne å oppdatere kanban brettet og hadde resultert i færre git feil, og merge feil.


# Krav og spesifikasjon

Det vi startet med som MVP, og hva som er gjort:
Vise et vindu på skjermen - Gjort
Vise et spillebrett - Gjort
Vise spiller på spillebrett - Gjort
Flytte spiller (vha taster e.l.) - Gjort
Spiller interagerer med terreng - Gjort
Spiller har poeng og interagerer med poenggjenstander - Gjort
Vise fiender/fest-folk; de skal interagere med terreng og spiller - Gjort.
Spiller kan dø (ved kontakt med fiender) - Gjort
Mål for spillbrett drepe alle fiender - Gjort
Start-skjerm ved oppstart / game over / hjelpeskjerm - Gjort

Vi har med andre ord gjort oss ferdig med MVP. Siden sist har vi fokusert på å komme oss forbi MVP, så de punktene vi manglet har vært hovedfokuset vårt. Dette er hvordan vi løste det vi manglet:
6. Fra kunden:

   “Vi ønsker å se progresjonen i spillet og ha oversikt over hvilken level man er i til en hver tid. Vi ville også se livtotalen til spilleren.”


   For dette punkter har vi laget en “HUD” som bl.a. holder kontroll på hvor mange fiender som har blitt eliminert, og dette er våre “poenggjenstander”. Når man har drept alle fiendene som spawner på en bane, vil døren til neste level åpne seg og man vil få opp piler som viser veien dit.

7. Fra kunden:
   “Vi ønsker oss fiender som skal gå mot å “angripe” spilleren, og at fiendene skal kunne gå de samme stedene som spilleren.”


   Fiender er laget og bruker de samme kollisjonsgrensene som hovedspilleren. Vi bestemte oss for at fiendene ikke skal skyte egne prosjektiler, men istede gå mot hovedspilleren også vil spilleren ta damage når man er i kontakt med fiendene. Det vil også lage en lyd som indikerer at man tar skade.


8. Fra kunden:

   “Vi ønsker oss at spilleren skal ta skade av å være i kontakt med spilleren, og at det skal komme opp en skjerm som sier at man har tapt spillet når livtotalen når null”


   Når spillerens liv når 0 vil man få opp en gameover screen. Spilleren har 100 liv til å begynne med, og tar 5 og 5 skade i kontakt med fiender.


9. Fra kunden:

   “Vi vil at spillets mål skal være å eliminere alle fiendene på hver bane, for å komme seg til den siste bane og vinne spillet”


   Dette er gjort ved at man først må drepe alle fiende på hver level, og til slutt gå inn døren på den siste banen. Man vil da få opp en GameCompletedScreen som sier at man har vunnet.

10. Fra kunden:

    “Vi ønsker at det skal være en meny når man starter spillet, og at det her skal finnes en skjerm som forklarer hvordan spillet spilles og hvilke knapper som skal brukes. Vi vil også ha en pausemeny inne i spillet”


Dette er gjort med bruk av setScreen i oppstartsmenyen, og ingame menyen er brukt ved at ulike “tables” vises. Hjelpeskjermen viser hvilke knapper som brukes, og hva som er målet med spillet. Vi slet litt med å få opp nye skjermer i pausemenyen fordi det “slettet progresjonen i spillet, så i motsetning til startmenyen som bruker “setScreen”, er pausemenyen laget som tabeller som bare tegnes og fjernes over det eksisterende spillet.
Vi prioriterte først at fiendene interagerer med mapet og kolliderer med objekter på mappet (vegger og andre ting) og deretter at de kolliderer med spiller. Så utviklet vi HUD (heads up display) for å vise liv, xp, level, og antall fiender drept.
Utover MVP har vi prioritert å få til et bra Powerup-system, som aktiveres når man har eliminert nok fiender til å “levle opp”. Da vil man få opp et tilfeldig valg av 3 powerups, som blir sterkere og sterkere for hvor langt du kommer. Vi har også lagt inn lyder for de forskjellige prosjektilene, til fiender og spiller og musikk lagd i FL STUDIO 21. Majoriteten av lydene har vi laget selv, med unntak av noen lyder som har blitt tatt fra en youtubers stemme. Lydene er laget ved hjelp av en mikrofon og Audacity som er et gratis lyd-redigeringsprogram som kan brukes privat, for utdanning og for kommersielle behov.

Vi har ikke justert MVP-kravene, ettersom vi mener de originale gir oss et spill som fint kan leveres til kunden.
Vi har fått til de aller fleste kravene til spesifikke egenskapene, bortsette fra objektfabrikker på som er basert på strenger.


# Produkt og kode

Dette har vi fikset siden sist:

Kollisjon

Kollisjonen i spillet fungerer ved hjelp av libGDX sin Rectangle class og dens funksjoner.

BOX2D

I starten testet vi box2D, en fysikkmotor som kan blant annet brukes i platformer-spill: Men denne spillmotoren gjorde bare ting verre. Ved å justere tyngdekraften til 0 kunne vi simulere top down fysikkene vi gikk for. Men dette gjorde at spillet spilltes som om du var på månen. Alle entiteter fløt rundt som om de skulle være på skøyter. På grunn av dette bestemte vi oss for å kode inn kollisjonene selv ved hjelp av Rectangle.

overlap()

Denne funksjonen er den mest brukte funksjonen for å håndtere collisions. Den sjekker om 2 rektangler overlapper på et sted og returnerer true om sant. Men dette var ikke nok til å få spilleren og fiendene til å kollidere med mapets objekter. Vi måtte legge inn kode som “dyttet” entitetene som overlappet ut av de solide objektenes rektangel.



Ved hjelp av matte, delte vi opp alle entiteter og mapobjekter inn i 4. Spillet sjekker hvor på rektangelet du kolliderer, og endrer koordinatene sånn at du ender opp på det eksakte punktet der du gjennomtrengte rektangelet


Vi har ikke brukt noen programmer for å fiksa bugs, og har istedet playtestet spillet en del for å oppdage potensielle feil.

Vi har klart å skrive forklaringer for mesteparten av koden vår ved hjelp av docs som ligger mellom kodelinjene